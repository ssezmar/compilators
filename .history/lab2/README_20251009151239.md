# Синтаксический анализатор на C++

Полнофункциональный инструмент для разбора исходного кода на языке С-подобной грамматики: выполняет лексический анализ, строит дерево синтаксического разбора и отображает результаты.

***

## Оглавление

1. [Введение](#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5)
2. [Установка и запуск](#%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B8-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA)
3. [Описание компонентов](#%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
4. [Алгоритмы и подходы](#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D0%BF%D0%BE%D0%B4%D1%85%D0%BE%D0%B4%D1%8B)
5. [Формат вывода](#%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0)
6. [Пример работы](#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B)
7. [Заключение](#%D0%B7%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5)

***

## Введение

Этот проект демонстрирует **интеграцию лексического и синтаксического анализатора** для учебных задач по теории компиляторов.

- **Лексер** разбивает текст на токены: ключевые слова, идентификаторы, константы, операторы, разделители и комментарии.
- **Парсер** (метод рекурсивного спуска) проверяет соответствие грамматике, строит AST и сообщает об ошибках.

Цель — понять внутренние механизмы первых двух этапов трансляции и получить универсальный инструмент для разбора небольших языков.

***

## Установка и запуск

**Требования:**

- Компилятор C++11 или выше
- GNU Make

**Сборка:**

```bash
git clone <repo-url>
cd <repo>
make
```

**Запуск:**

```bash
./syntax input.cpp
```

- При успешном разборе выводится сообщение и дерево AST.
- При ошибке — подробная диагностика с указанием строки и позиции.

***

## Описание компонентов

1. **lexer.h / lexer.cpp**
    - Класс `Lexer` последовательно сканирует исходный текст.
    - Методы: `next()` возвращает следующий `Token`.
    - Используется _расширяемый автомат_ + хеширование ключевых слов + бинарный поиск операторов.
2. **parser.h / parser.cpp**
    - Класс `Parser` реализует метод рекурсивного спуска по LL-грамматике.
    - Основные методы: `parseProgram()`, `parseStmtList()`, `parseStmt()`, `parseExpr()`, `parseTerm()`, `parseFactor()`.
    - Результат — дерево AST, выводимое методом `AST::print()`.
3. **main.cpp**
    - Читает файл, создает `Lexer` и `Parser`, запускает разбор и печатает дерево или ошибку.
4. **Makefile**
    - Цели: `all`, `clean`, `test`
    - Простая сборка и запуск тестов

***

## Алгоритмы и подходы

### 1. Расширяемый конечный автомат (Лексер)

- Модель: состояния (`START`, `IDENTIFIER_ST`, `INTEGER_ST`, `FLOAT_ST`, `STRING_ST` и др.) + функция переходов.
- Обработка каждой лексемы за O(ℓ), ℓ — длина токена.
- Позволяет детерминировано распознавать регулярные шаблоны.


### 2. Хеширование ключевых слов

- `std::unordered_set` хранит список ключевых слов.
- Поиск в среднем O(1), гарантируя быстрый переход от идентификатора к ключевому слову.


### 3. Бинарный поиск операторов

- Операторы хранятся в отсортированном `std::vector<string>`.
- `std::binary_search` выполняет поиск за O(log N), N≈32.


### 4. Рекурсивный спуск (Парсер)

- Элементарный LL(1)-парсер: для каждого нетерминала своя функция.
- Грамматика без левой рекурсии: выражения строятся через `parseExpr` → `parseTerm` → `parseFactor`.
- Обработка ошибок: выброс исключения + паническое восстановление не реализовано, но легко добавить.

***

## Формат вывода

- **Успех**:

```
Parsing succeeded
Program
  StmtList
    If
      Expr
        Term …
    TermStmt …
```

- **Ошибка**:

```
Parse error at 3:15: Expected ';' but found '}'
```


AST печатается с отступами, визуализируя структуру программы.

***

## Пример работы

Исходник `example.cpp`:

```cpp
int main() {
  int x = 10;
  if (x > 5) x = x + 1;
}
```

**Команда:**

```bash
./syntax example.cpp
```

**Вывод:**

```
Parsing succeeded
Program
  StmtList
    Stmt ExprStmt
      Expr
        Term
          Factor Num:10
    Stmt If
      Expr
        Term
          Factor Id:x
      Stmt ExprStmt
        Expr
          Term
            Factor Id:x
```


***

## Заключение

Данный проект служит наглядным примером:

- Интеграции **лексического** и **синтаксического** анализа.
- Применения классических алгоритмов (автомат, хеширование, бинарный поиск, рекурсивный спуск).
- Основой для изучения более сложных методов (LL(k), LR-анализ).

Используйте этот инструмент для экспериментов с грамматиками, расширяйте его новыми правилами и тестируйте на собственных языках!

